import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { testClient } from 'hono/testing'
import { Hono } from 'hono'
import { auth } from '../auth.js'
import type { Database } from '@prodobit/database'
import { users, tenants } from '@prodobit/database/schema'
import * as bcrypt from 'bcryptjs'
import * as jwt from 'jsonwebtoken'

// Mock dependencies
vi.mock('bcryptjs', () => ({
  hash: vi.fn(),
  compare: vi.fn()
}))
vi.mock('jsonwebtoken', () => ({
  sign: vi.fn(),
  verify: vi.fn()
}))

const mockBcrypt = vi.mocked(bcrypt)
const mockJwt = vi.mocked(jwt)

describe('Auth API', () => {
  let app: Hono
  let client: any
  let mockDb: any

  beforeEach(() => {
    vi.clearAllMocks()
    
    // Setup mocks
    mockBcrypt.hash.mockResolvedValue('hashedPassword123')
    mockBcrypt.compare.mockResolvedValue(true)
    mockJwt.sign.mockReturnValue('jwt-token-123')
    mockJwt.verify.mockReturnValue({ userId: 'user-123', tenantId: 'tenant-123' })
    
    // Create app with auth routes
    app = new Hono()
    
    // Mock database
    mockDb = {
      query: {
        users: {
          findFirst: vi.fn(),
          findMany: vi.fn()
        },
        tenants: {
          findFirst: vi.fn()
        }
      },
      insert: vi.fn().mockReturnValue({
        values: vi.fn().mockReturnValue({
          returning: vi.fn()
        })
      }),
      select: vi.fn().mockReturnValue({
        from: vi.fn().mockReturnValue({
          where: vi.fn().mockResolvedValue([])
        })
      })
    }

    // Set context variables
    app.use('*', async (c, next) => {
      c.set('db', mockDb)
      c.set('enabledModules', new Set(['core']))
      await next()
    })

    app.route('/auth', auth)
    client = testClient(app)
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('POST /auth/register', () => {
    const validRegisterData = {
      email: 'test@example.com',
      password: 'SecurePassword123!',
      firstName: 'John',
      lastName: 'Doe',
      tenantName: 'Test Company'
    }

    it('should register new user successfully', async () => {
      // Mock bcrypt hash
      mockBcrypt.hash.mockResolvedValue('hashedPassword123')
      
      // Mock user doesn't exist
      mockDb.query.users.findFirst.mockResolvedValue(null)
      
      // Mock tenant creation
      const mockTenant = {
        id: 'tenant-123',
        name: 'Test Company',
        domain: 'test-company'
      }
      mockDb.insert.mockReturnValue({
        values: vi.fn().mockReturnValue({
          returning: vi.fn().mockResolvedValue([mockTenant])
        })
      })

      // Mock user creation
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
        tenantId: 'tenant-123'
      }
      mockDb.insert.mockReturnValue({
        values: vi.fn().mockReturnValue({
          returning: vi.fn().mockResolvedValue([mockUser])
        })
      })

      // Mock JWT sign
      mockJwt.sign.mockReturnValue('jwt-token-123')

      const res = await client.auth.register.$post({
        json: validRegisterData
      })

      expect(res.status).toBe(201)
      
      const data = await res.json()
      expect(data).toEqual({
        message: 'Registration successful',
        user: {
          id: 'user-123',
          email: 'test@example.com',
          firstName: 'John',
          lastName: 'Doe',
          tenantId: 'tenant-123'
        },
        token: 'jwt-token-123'
      })

      expect(mockBcrypt.hash).toHaveBeenCalledWith('SecurePassword123!', 12)
      expect(mockJwt.sign).toHaveBeenCalledWith(
        {
          userId: 'user-123',
          email: 'test@example.com',
          tenantId: 'tenant-123',
          roles: ['admin']
        },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      )
    })

    it('should return 400 for invalid email format', async () => {
      const invalidData = {
        ...validRegisterData,
        email: 'invalid-email'
      }

      const res = await client.auth.register.$post({
        json: invalidData
      })

      expect(res.status).toBe(400)
      
      const data = await res.json()
      expect(data.error).toContain('Invalid email format')
    })

    it('should return 400 for weak password', async () => {
      const invalidData = {
        ...validRegisterData,
        password: '123'
      }

      const res = await client.auth.register.$post({
        json: invalidData
      })

      expect(res.status).toBe(400)
      
      const data = await res.json()
      expect(data.error).toContain('Password must be at least 8 characters')
    })

    it('should return 409 when user already exists', async () => {
      const existingUser = {
        id: 'user-456',
        email: 'test@example.com'
      }
      mockDb.query.users.findFirst.mockResolvedValue(existingUser)

      const res = await client.auth.register.$post({
        json: validRegisterData
      })

      expect(res.status).toBe(409)
      
      const data = await res.json()
      expect(data.error).toBe('User with this email already exists')
    })

    it('should handle missing required fields', async () => {
      const incompleteData = {
        email: 'test@example.com',
        password: 'SecurePassword123!'
        // Missing firstName, lastName, tenantName
      }

      const res = await client.auth.register.$post({
        json: incompleteData
      })

      expect(res.status).toBe(400)
      
      const data = await res.json()
      expect(data.error).toContain('required')
    })
  })

  describe('POST /auth/login', () => {
    const validLoginData = {
      email: 'test@example.com',
      password: 'SecurePassword123!'
    }

    it('should login successfully with valid credentials', async () => {
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        passwordHash: 'hashedPassword123',
        firstName: 'John',
        lastName: 'Doe',
        tenantId: 'tenant-123',
        roles: ['admin']
      }

      mockDb.query.users.findFirst.mockResolvedValue(mockUser)
      mockBcrypt.compare.mockResolvedValue(true)
      mockJwt.sign.mockReturnValue('jwt-token-123')

      const res = await client.auth.login.$post({
        json: validLoginData
      })

      expect(res.status).toBe(200)
      
      const data = await res.json()
      expect(data).toEqual({
        message: 'Login successful',
        user: {
          id: 'user-123',
          email: 'test@example.com',
          firstName: 'John',
          lastName: 'Doe',
          tenantId: 'tenant-123',
          roles: ['admin']
        },
        token: 'jwt-token-123'
      })

      expect(mockBcrypt.compare).toHaveBeenCalledWith('SecurePassword123!', 'hashedPassword123')
    })

    it('should return 401 for non-existent user', async () => {
      mockDb.query.users.findFirst.mockResolvedValue(null)

      const res = await client.auth.login.$post({
        json: validLoginData
      })

      expect(res.status).toBe(401)
      
      const data = await res.json()
      expect(data.error).toBe('Invalid email or password')
    })

    it('should return 401 for incorrect password', async () => {
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        passwordHash: 'hashedPassword123'
      }

      mockDb.query.users.findFirst.mockResolvedValue(mockUser)
      mockBcrypt.compare.mockResolvedValue(false)

      const res = await client.auth.login.$post({
        json: validLoginData
      })

      expect(res.status).toBe(401)
      
      const data = await res.json()
      expect(data.error).toBe('Invalid email or password')
    })

    it('should return 400 for missing email', async () => {
      const invalidData = {
        password: 'SecurePassword123!'
      }

      const res = await client.auth.login.$post({
        json: invalidData
      })

      expect(res.status).toBe(400)
      
      const data = await res.json()
      expect(data.error).toContain('Email is required')
    })

    it('should return 400 for missing password', async () => {
      const invalidData = {
        email: 'test@example.com'
      }

      const res = await client.auth.login.$post({
        json: invalidData
      })

      expect(res.status).toBe(400)
      
      const data = await res.json()
      expect(data.error).toContain('Password is required')
    })
  })

  describe('POST /auth/refresh', () => {
    it('should refresh token successfully', async () => {
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        tenantId: 'tenant-123',
        roles: ['admin']
      }

      // Mock JWT verify for refresh token
      mockJwt.verify.mockReturnValue({
        userId: 'user-123',
        email: 'test@example.com',
        tenantId: 'tenant-123'
      })

      mockDb.query.users.findFirst.mockResolvedValue(mockUser)
      mockJwt.sign.mockReturnValue('new-jwt-token-456')

      const res = await client.auth.refresh.$post({
        json: { refreshToken: 'valid-refresh-token' }
      })

      expect(res.status).toBe(200)
      
      const data = await res.json()
      expect(data).toEqual({
        message: 'Token refreshed successfully',
        token: 'new-jwt-token-456'
      })
    })

    it('should return 401 for invalid refresh token', async () => {
      mockJwt.verify.mockImplementation(() => {
        throw new Error('Invalid token')
      })

      const res = await client.auth.refresh.$post({
        json: { refreshToken: 'invalid-refresh-token' }
      })

      expect(res.status).toBe(401)
      
      const data = await res.json()
      expect(data.error).toBe('Invalid refresh token')
    })

    it('should return 401 when user no longer exists', async () => {
      mockJwt.verify.mockReturnValue({
        userId: 'user-123',
        email: 'test@example.com'
      })

      mockDb.query.users.findFirst.mockResolvedValue(null)

      const res = await client.auth.refresh.$post({
        json: { refreshToken: 'valid-refresh-token' }
      })

      expect(res.status).toBe(401)
      
      const data = await res.json()
      expect(data.error).toBe('User not found')
    })
  })

  describe('POST /auth/logout', () => {
    it('should logout successfully', async () => {
      const res = await client.auth.logout.$post({})

      expect(res.status).toBe(200)
      
      const data = await res.json()
      expect(data).toEqual({
        message: 'Logout successful'
      })
    })
  })

  describe('GET /auth/me', () => {
    it('should return current user info when authenticated', async () => {
      const mockUser = {
        id: 'user-123',
        email: 'test@example.com',
        firstName: 'John',
        lastName: 'Doe',
        tenantId: 'tenant-123',
        roles: ['admin']
      }

      // Mock authenticated user in context
      app.use('*', async (c, next) => {
        c.set('user', mockUser)
        await next()
      })

      const res = await client.auth.me.$get()

      expect(res.status).toBe(200)
      
      const data = await res.json()
      expect(data.user).toEqual(mockUser)
    })

    it('should return 401 when not authenticated', async () => {
      // Don't set user in context

      const res = await client.auth.me.$get()

      expect(res.status).toBe(401)
      
      const data = await res.json()
      expect(data.error).toBe('Authentication required')
    })
  })

  describe('password validation', () => {
    it('should validate password strength correctly', () => {
      const validPasswords = [
        'SecurePassword123!',
        'MyP@ssw0rd123',
        'ComplexP@ss1'
      ]

      const invalidPasswords = [
        '123456',           // Too short
        'password',         // No numbers/symbols
        'PASSWORD123',      // No lowercase
        'password123',      // No uppercase
        'Password',         // No numbers/symbols
        'Pass123'          // Too short
      ]

      // Test would use the internal validation function
      // This is a conceptual test - actual implementation would be in the auth handler
    })
  })

  describe('email validation', () => {
    it('should validate email format correctly', () => {
      const validEmails = [
        'user@example.com',
        'test.email+tag@domain.co.uk',
        'user123@test-domain.com'
      ]

      const invalidEmails = [
        'invalid-email',
        '@domain.com',
        'user@',
        'user space@domain.com',
        ''
      ]

      // Test would use the internal validation function
      // This is a conceptual test - actual implementation would be in the auth handler
    })
  })

  describe('JWT token handling', () => {
    it('should generate token with correct payload', () => {
      const userData = {
        userId: 'user-123',
        email: 'test@example.com',
        tenantId: 'tenant-123',
        roles: ['admin']
      }

      mockJwt.sign.mockReturnValue('generated-token')

      // This would test the token generation logic in the auth service
      expect(mockJwt.sign).not.toHaveBeenCalled() // Initial state
    })

    it('should handle token expiration correctly', () => {
      mockJwt.verify.mockImplementation(() => {
        const error = new Error('Token expired')
        error.name = 'TokenExpiredError'
        throw error
      })

      // Test would verify expired token handling
      // This is a conceptual test
    })
  })

  describe('rate limiting', () => {
    it('should handle multiple login attempts', async () => {
      // This would test rate limiting if implemented
      // Multiple rapid requests to login endpoint
      const promises = Array(10).fill(null).map(() => 
        client.auth.login.$post({
          json: { email: 'test@example.com', password: 'wrong' }
        })
      )

      const results = await Promise.all(promises)
      
      // All should be 401 for wrong password, but rate limiting might kick in
      results.forEach(res => {
        expect([401, 429]).toContain(res.status)
      })
    })
  })

  describe('security headers', () => {
    it('should include security headers in responses', async () => {
      const res = await client.auth.login.$post({
        json: {
          email: 'test@example.com',
          password: 'password'
        }
      })

      // Check for security headers (if implemented)
      // expect(res.headers.get('X-Content-Type-Options')).toBe('nosniff')
      // expect(res.headers.get('X-Frame-Options')).toBe('DENY')
    })
  })
})