import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest'
import { ItemService } from '../ItemService.js'
import type { Database } from '@prodobit/database'
import { items, attributes, itemAttributes } from '@prodobit/database'
import { eq, and } from 'drizzle-orm'

// Mock database
const mockDatabase = {
  select: vi.fn(),
  insert: vi.fn(),
  update: vi.fn(),
  delete: vi.fn(),
  query: {
    items: {
      findMany: vi.fn(),
      findFirst: vi.fn()
    }
  }
} as unknown as Database

const mockDbQuery = {
  from: vi.fn(),
  where: vi.fn(),
  leftJoin: vi.fn(),
  returning: vi.fn(),
  set: vi.fn(),
  values: vi.fn(),
  limit: vi.fn(),
  orderBy: vi.fn(),
  select: vi.fn()
}

// Chain all methods to return the query object for method chaining
Object.keys(mockDbQuery).forEach(key => {
  if (typeof mockDbQuery[key as keyof typeof mockDbQuery] === 'function') {
    mockDbQuery[key as keyof typeof mockDbQuery] = vi.fn().mockReturnValue(mockDbQuery)
  }
})

describe('ItemService', () => {
  let itemService: ItemService
  let mockDb: Database

  beforeEach(() => {
    vi.clearAllMocks()
    
    // Reset all mock functions to return the mockDbQuery for chaining
    Object.keys(mockDbQuery).forEach(key => {
      if (typeof mockDbQuery[key as keyof typeof mockDbQuery] === 'function') {
        mockDbQuery[key as keyof typeof mockDbQuery] = vi.fn().mockReturnValue(mockDbQuery)
      }
    })
    
    mockDb = mockDatabase
    
    // Setup default mock implementations
    mockDb.select = vi.fn().mockReturnValue(mockDbQuery)
    mockDb.insert = vi.fn().mockReturnValue(mockDbQuery)
    mockDb.update = vi.fn().mockReturnValue(mockDbQuery)
    mockDb.delete = vi.fn().mockReturnValue(mockDbQuery)
    
    itemService = new ItemService(mockDb)
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('createItem', () => {
    const mockItemData = {
      tenantId: 'tenant-123',
      name: 'Test Product',
      code: 'TEST-001',
      itemType: 'product' as const,
      status: 'active',
      isInventoryItem: true,
      isStockItem: true,
      isVariant: false,
      isAbstract: false,
      specificData: {
        unit: 'pc',
        productType: 'manufactured'
      },
      categoryId: 'category-123'
    }

    it('should create item successfully', async () => {
      const mockCreatedItem = {
        id: 'item-123',
        tenantId: mockItemData.tenantId,
        code: 'ITM493523UT', // Generated code as per real implementation
        name: mockItemData.name,
        itemType: mockItemData.itemType,
        status: mockItemData.status,
        isAbstract: mockItemData.isAbstract,
        createdAt: new Date(),
        updatedAt: new Date()
      }

      // Mock the complex flow - first returning the base item
      mockDbQuery.returning.mockResolvedValue([mockCreatedItem])

      const result = await itemService.createItem(mockItemData)

      expect(mockDb.insert).toHaveBeenCalledWith(items)
      expect(mockDbQuery.values).toHaveBeenCalled()
      expect(mockDbQuery.returning).toHaveBeenCalled()
      
      // Result should be the created item
      expect(result).toBeDefined()
    })

    it('should handle database errors', async () => {
      mockDbQuery.returning.mockRejectedValue(new Error('Database error'))

      await expect(itemService.createItem(mockItemData))
        .rejects.toThrow('Database error')
    })

    it('should handle missing tenantId', async () => {
      const invalidData = {
        name: 'Test Product',
        itemType: 'product'
      } as any

      // Since ItemService relies on DB constraints, this will likely cause a DB error
      await expect(itemService.createItem(invalidData))
        .rejects.toThrow()
    })
  })

  describe('getItemWithDetails', () => {
    it('should return item with details when found', async () => {
      const mockItem = {
        id: 'item-123',
        name: 'Test Product',
        code: 'TEST-001',
        tenantId: 'tenant-123',
        itemType: 'product'
      }

      // Mock the complex select query that getItemWithDetails uses
      mockDbQuery.where.mockResolvedValue([mockItem])

      const result = await itemService.getItemWithDetails('item-123', 'tenant-123')

      expect(mockDb.select).toHaveBeenCalled()
      expect(result).toBeDefined()
    })

    it('should throw error when item not found', async () => {
      mockDbQuery.where.mockResolvedValue([])

      await expect(itemService.getItemWithDetails('non-existent', 'tenant-123'))
        .rejects.toThrow('Item not found')
    })

    it('should handle database errors', async () => {
      mockDbQuery.where.mockRejectedValue(new Error('Database error'))

      await expect(itemService.getItemWithDetails('item-123', 'tenant-123'))
        .rejects.toThrow('Database error')
    })
  })

  describe('getItems', () => {
    it('should return items for tenant', async () => {
      const mockItems = [
        { id: 'item-1', name: 'Product 1', tenantId: 'tenant-123' },
        { id: 'item-2', name: 'Product 2', tenantId: 'tenant-123' }
      ]

      mockDbQuery.where.mockResolvedValue(mockItems)

      const result = await itemService.getItems('tenant-123')

      expect(mockDb.select).toHaveBeenCalled()
      expect(result).toEqual(mockItems)
    })

    it('should filter items by type', async () => {
      const mockItems = [
        { id: 'item-1', name: 'Product 1', itemType: 'product' }
      ]

      mockDbQuery.where.mockResolvedValue(mockItems)

      const result = await itemService.getItems('tenant-123', { itemType: 'product' })

      expect(result).toEqual(mockItems)
    })
  })

  describe('getCategories', () => {
    it('should return categories for tenant', async () => {
      const mockCategories = [
        { id: 'cat-1', name: 'Electronics', tenantId: 'tenant-123' },
        { id: 'cat-2', name: 'Books', tenantId: 'tenant-123' }
      ]

      mockDb.query.itemCategories = { findMany: vi.fn().mockResolvedValue(mockCategories) }

      const result = await itemService.getCategories('tenant-123')

      expect(mockDb.query.itemCategories.findMany).toHaveBeenCalled()
      expect(result).toEqual(mockCategories)
    })

    it('should filter categories by item type', async () => {
      const mockCategories = [
        { id: 'cat-1', name: 'Electronics', itemType: 'product' }
      ]

      mockDb.query.itemCategories = { findMany: vi.fn().mockResolvedValue(mockCategories) }

      const result = await itemService.getCategories('tenant-123', 'product')

      expect(result).toEqual(mockCategories)
    })
  })

  describe('deleteItem', () => {
    it('should delete item successfully', async () => {
      const mockDeletedItem = {
        id: 'item-123',
        name: 'Deleted Product',
        tenantId: 'tenant-123'
      }

      mockDbQuery.returning.mockResolvedValue([mockDeletedItem])

      const result = await itemService.deleteItem('item-123', 'tenant-123')

      expect(mockDb.delete).toHaveBeenCalledWith(items)
      expect(mockDbQuery.where).toHaveBeenCalledWith(
        and(
          eq(items.id, 'item-123'),
          eq(items.tenantId, 'tenant-123')
        )
      )
      expect(result).toBe(true)
    })

    it('should return false when item not found', async () => {
      mockDbQuery.returning.mockResolvedValue([])

      const result = await itemService.deleteItem('non-existent', 'tenant-123')

      expect(result).toBe(false)
    })
  })

  describe('getItemVariants', () => {
    it('should return variants for an item', async () => {
      const mockVariants = [
        {
          id: 'variant-1',
          itemId: 'item-123',
          variantAttributes: { color: 'red', size: 'large' }
        }
      ]

      mockDb.query.itemVariants = { findMany: vi.fn().mockResolvedValue(mockVariants) }

      const result = await itemService.getItemVariants('item-123', 'tenant-123')

      expect(mockDb.query.itemVariants.findMany).toHaveBeenCalled()
      expect(result).toEqual(mockVariants)
    })
  })

  describe('createCategory', () => {
    it('should create category successfully', async () => {
      const mockCategoryData = {
        name: 'Electronics',
        tenantId: 'tenant-123'
      }
      
      const mockCategory = {
        id: 'cat-123',
        ...mockCategoryData,
        createdAt: new Date()
      }

      mockDbQuery.returning.mockResolvedValue([mockCategory])

      const result = await itemService.createCategory(mockCategoryData)

      expect(mockDb.insert).toHaveBeenCalled()
      expect(result).toEqual(mockCategory)
    })

    it('should handle database errors', async () => {
      const mockCategoryData = {
        name: 'Electronics',
        tenantId: 'tenant-123'
      }
      
      mockDbQuery.returning.mockRejectedValue(new Error('Database error'))

      await expect(itemService.createCategory(mockCategoryData))
        .rejects.toThrow('Database error')
    })
  })

  describe('createItemVariant', () => {
    it('should create item variant successfully', async () => {
      const mockVariantData = {
        itemId: 'item-123',
        tenantId: 'tenant-123',
        variantAttributes: { color: 'red', size: 'large' },
        additionalData: {}
      }
      
      const mockVariant = {
        id: 'variant-123',
        ...mockVariantData,
        createdAt: new Date()
      }

      mockDbQuery.returning.mockResolvedValue([mockVariant])

      const result = await itemService.createItemVariant(mockVariantData)

      expect(mockDb.insert).toHaveBeenCalled()
      expect(result).toEqual(mockVariant)
    })

    it('should handle invalid variant data', async () => {
      const invalidData = {
        itemId: '',
        tenantId: 'tenant-123'
      } as any
      
      mockDbQuery.returning.mockRejectedValue(new Error('Validation error'))

      await expect(itemService.createItemVariant(invalidData))
        .rejects.toThrow('Validation error')
    })
  })

  describe('searchItems', () => {
    const mockSearchResults = [
      { id: 'item-1', name: 'Laptop Computer', sku: 'COMP-001' },
      { id: 'item-2', name: 'Desktop Computer', sku: 'COMP-002' }
    ]

    it('should search items by name and SKU', async () => {
      mockDbQuery.returning.mockResolvedValue(mockSearchResults)

      const result = await itemService.searchItems('computer', 'tenant-123')

      expect(result).toEqual(mockSearchResults)
    })

    it('should return empty array when no matches found', async () => {
      mockDbQuery.returning.mockResolvedValue([])

      const result = await itemService.searchItems('nonexistent', 'tenant-123')

      expect(result).toEqual([])
    })

    it('should handle empty search term', async () => {
      mockDb.query.items.findMany = vi.fn().mockResolvedValue(mockSearchResults)

      const result = await itemService.searchItems('', 'tenant-123')

      expect(mockDb.query.items.findMany).toHaveBeenCalledWith({
        where: eq(items.tenantId, 'tenant-123'),
        limit: 100
      })
      expect(result).toEqual(mockSearchResults)
    })
  })

  describe('getItemCategories', () => {
    it('should return item categories with filters', async () => {
      const mockCategories = [
        { id: 'cat-1', name: 'Electronics', itemType: 'product' },
        { id: 'cat-2', name: 'Services', itemType: 'service' }
      ]

      mockDb.query.itemCategories = { findMany: vi.fn().mockResolvedValue(mockCategories) }

      const result = await itemService.getItemCategories({
        tenantId: 'tenant-123',
        itemType: 'product'
      })

      expect(mockDb.query.itemCategories.findMany).toHaveBeenCalled()
      expect(result).toEqual(mockCategories)
    })
  })

  describe('createItemCategory', () => {
    it('should create item category successfully', async () => {
      const mockCategoryData = {
        name: 'New Category',
        tenantId: 'tenant-123',
        itemType: 'product'
      }
      
      const mockCategory = {
        id: 'cat-new',
        ...mockCategoryData,
        createdAt: new Date()
      }

      mockDbQuery.returning.mockResolvedValue([mockCategory])

      const result = await itemService.createItemCategory(mockCategoryData)

      expect(mockDb.insert).toHaveBeenCalled()
      expect(result).toEqual(mockCategory)
    })

    it('should handle duplicate category names', async () => {
      const mockCategoryData = {
        name: 'Existing Category',
        tenantId: 'tenant-123',
        itemType: 'product'
      }
      
      mockDbQuery.returning.mockRejectedValue(new Error('Unique constraint violation'))

      await expect(itemService.createItemCategory(mockCategoryData))
        .rejects.toThrow('Unique constraint violation')
    })
  })
})