import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest'
import { drizzle } from 'drizzle-orm/postgres-js'
import postgres from 'postgres'
import { migrate } from 'drizzle-orm/postgres-js/migrator'
import { 
  tenants, 
  users, 
  parties, 
  items, 
  attributes, 
  attributeValues,
  locations,
  assets,
  salesOrders,
  salesOrderItems
} from '../schema/index.js'
import { eq, and } from 'drizzle-orm'
import { PostgreSqlContainer } from '@testcontainers/postgresql'

describe('Database Schema Integration Tests', () => {
  let container: any
  let db: any
  let client: any

  beforeAll(async () => {
    // Start PostgreSQL container
    container = await new PostgreSqlContainer('postgres:16-alpine')
      .withDatabase('test_db')
      .withUsername('test_user')
      .withPassword('test_pass')
      .withExposedPorts(5432)
      .start()

    const connectionString = container.getConnectionUri()

    // Create database connection
    client = postgres(connectionString, { max: 1 })
    db = drizzle(client)

    // Run migrations
    await migrate(db, { migrationsFolder: './packages/database/drizzle' })
  }, 60000) // 60 second timeout for container setup

  afterAll(async () => {
    if (client) {
      await client.end()
    }
    if (container) {
      await container.stop()
    }
  })

  beforeEach(async () => {
    // Clean up all tables before each test
    await db.delete(salesOrderItems)
    await db.delete(salesOrders)
    await db.delete(attributeValues)
    await db.delete(assets)
    await db.delete(items)
    await db.delete(attributes)
    await db.delete(locations)
    await db.delete(parties)
    await db.delete(users)
    await db.delete(tenants)
  })

  describe('Tenant Schema', () => {
    it('should create tenant successfully', async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Test Company',
        domain: 'test-company',
        settings: { timezone: 'UTC', currency: 'USD' }
      }).returning()

      expect(tenant).toBeDefined()
      expect(tenant.id).toBeDefined()
      expect(tenant.name).toBe('Test Company')
      expect(tenant.domain).toBe('test-company')
      expect(tenant.settings).toEqual({ timezone: 'UTC', currency: 'USD' })
      expect(tenant.createdAt).toBeDefined()
      expect(tenant.updatedAt).toBeDefined()
    })

    it('should enforce unique domain constraint', async () => {
      // Create first tenant
      await db.insert(tenants).values({
        name: 'Company 1',
        domain: 'same-domain'
      })

      // Try to create second tenant with same domain
      await expect(
        db.insert(tenants).values({
          name: 'Company 2',
          domain: 'same-domain'
        })
      ).rejects.toThrow()
    })

    it('should validate domain format', async () => {
      // Test invalid domain with spaces
      await expect(
        db.insert(tenants).values({
          name: 'Test Company',
          domain: 'invalid domain'
        })
      ).rejects.toThrow()
    })

    it('should handle JSON settings properly', async () => {
      const complexSettings = {
        features: {
          multiCurrency: true,
          inventory: true,
          manufacturing: false
        },
        notifications: {
          email: true,
          sms: false
        },
        limits: {
          users: 100,
          storage: '10GB'
        }
      }

      const [tenant] = await db.insert(tenants).values({
        name: 'Complex Settings Company',
        domain: 'complex-settings',
        settings: complexSettings
      }).returning()

      expect(tenant.settings).toEqual(complexSettings)
    })
  })

  describe('User Schema', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'User Test Company',
        domain: 'user-test'
      }).returning()
      tenantId = tenant.id
    })

    it('should create user successfully', async () => {
      const [user] = await db.insert(users).values({
        displayName: 'John Doe',
        status: 'active'
      }).returning()

      expect(user).toBeDefined()
      expect(user.id).toBeDefined()
      expect(user.displayName).toBe('John Doe')
      expect(user.status).toBe('active')
    })

    it('should allow multiple users with same display name', async () => {
      await db.insert(users).values({
        displayName: 'John Smith',
        status: 'active'
      })

      // Should not throw error - display name doesn't need to be unique
      const [user2] = await db.insert(users).values({
        displayName: 'John Smith',
        status: 'active'
      }).returning()

      expect(user2).toBeDefined()
    })

    it('should handle user status correctly', async () => {
      const [user] = await db.insert(users).values({
        displayName: 'Status User',
        status: 'inactive'
      }).returning()

      expect(user.status).toBe('inactive')
    })

    it('should handle two factor authentication settings', async () => {
      const [user] = await db.insert(users).values({
        displayName: '2FA User',
        twoFactorEnabled: true,
        twoFactorSecret: 'secret-key-123',
        status: 'active'
      }).returning()

      expect(user.twoFactorEnabled).toBe(true)
      expect(user.twoFactorSecret).toBe('secret-key-123')
    })
  })

  describe('Party Schema', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Party Test Company',
        domain: 'party-test'
      }).returning()
      tenantId = tenant.id
    })

    it('should create party successfully', async () => {
      const [party] = await db.insert(parties).values({
        partyType: 'customer',
        code: 'CUST-001',
        status: 'active',
        tenantId
      }).returning()

      expect(party).toBeDefined()
      expect(party.partyType).toBe('customer')
      expect(party.code).toBe('CUST-001')
      expect(party.status).toBe('active')
    })

    it('should enforce unique code per tenant', async () => {
      await db.insert(parties).values({
        partyType: 'customer',
        code: 'DUPLICATE-CODE',
        tenantId
      })

      await expect(
        db.insert(parties).values({
          partyType: 'supplier',
          code: 'DUPLICATE-CODE',
          tenantId
        })
      ).rejects.toThrow()
    })

    it('should allow same code in different tenants', async () => {
      const [tenant2] = await db.insert(tenants).values({
        name: 'Second Company',
        domain: 'second-company'
      }).returning()

      await db.insert(parties).values({
        partyType: 'customer',
        code: 'SAME-CODE',
        tenantId
      })

      // Should not throw error for different tenant
      const [party2] = await db.insert(parties).values({
        partyType: 'supplier',
        code: 'SAME-CODE',
        tenantId: tenant2.id
      }).returning()

      expect(party2).toBeDefined()
    })
  })

  describe('Item and Attribute Schema', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Item Test Company',
        domain: 'item-test'
      }).returning()
      tenantId = tenant.id
    })

    it('should create item successfully', async () => {
      const [item] = await db.insert(items).values({
        name: 'Test Product',
        itemType: 'product',
        code: 'TEST-001',
        tenantId
      }).returning()

      expect(item).toBeDefined()
      expect(item.name).toBe('Test Product')
      expect(item.code).toBe('TEST-001')
      expect(item.itemType).toBe('product')
      expect(item.status).toBe('active')
    })

    it('should enforce unique code per tenant', async () => {
      await db.insert(items).values({
        name: 'Product 1',
        itemType: 'product',
        code: 'DUPLICATE-CODE',
        tenantId
      })

      await expect(
        db.insert(items).values({
          name: 'Product 2',
          itemType: 'product',
          code: 'DUPLICATE-CODE',
          tenantId
        })
      ).rejects.toThrow()
    })

    it('should allow same code in different tenants', async () => {
      const [tenant2] = await db.insert(tenants).values({
        name: 'Second Company',
        domain: 'second-company'
      }).returning()

      await db.insert(items).values({
        name: 'Product 1',
        itemType: 'product',
        code: 'SAME-CODE',
        tenantId
      })

      // Should not throw error for different tenant
      const [item2] = await db.insert(items).values({
        name: 'Product 2',
        itemType: 'product',
        code: 'SAME-CODE',
        tenantId: tenant2.id
      }).returning()

      expect(item2).toBeDefined()
    })

    it('should create and link item attributes', async () => {
      // Create attribute
      const [attribute] = await db.insert(attributes).values({
        name: 'Color',
        entityType: 'items',
        dataType: 'text',
        tenantId
      }).returning()

      // Create item
      const [item] = await db.insert(items).values({
        name: 'Colorful Product',
        itemType: 'product',
        code: 'COLOR-001',
        tenantId
      }).returning()

      // Link attribute to item
      const [attributeValue] = await db.insert(attributeValues).values({
        entityId: item.id,
        entityType: 'items',
        attributeId: attribute.id,
        value: 'Red',
        tenantId
      }).returning()

      expect(attributeValue).toBeDefined()
      expect(attributeValue.value).toBe('Red')
    })

    it('should enforce unique entity-attribute pair', async () => {
      const [attribute] = await db.insert(attributes).values({
        name: 'Size',
        entityType: 'items',
        dataType: 'text',
        tenantId
      }).returning()

      const [item] = await db.insert(items).values({
        name: 'Sized Product',
        itemType: 'product',
        code: 'SIZE-001',
        tenantId
      }).returning()

      await db.insert(attributeValues).values({
        entityId: item.id,
        entityType: 'items',
        attributeId: attribute.id,
        value: 'Large',
        tenantId
      })

      // Should not allow duplicate entity-attribute pair
      await expect(
        db.insert(attributeValues).values({
          entityId: item.id,
          entityType: 'items',
          attributeId: attribute.id,
          value: 'Medium', // Different value but same entity-attribute pair
          tenantId
        })
      ).rejects.toThrow()
    })
  })

  describe('Basic Schema Operations', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Basic Test Company',
        domain: 'basic-test'
      }).returning()
      tenantId = tenant.id
    })

    it('should perform basic CRUD operations', async () => {
      // Test creating multiple entities in sequence
      const [user] = await db.insert(users).values({
        displayName: 'Test User',
        status: 'active'
      }).returning()

      const [party] = await db.insert(parties).values({
        partyType: 'customer',
        code: 'TEST-CUSTOMER',
        tenantId
      }).returning()

      const [item] = await db.insert(items).values({
        name: 'Test Item',
        itemType: 'product',
        code: 'TEST-ITEM',
        tenantId
      }).returning()

      expect(user.displayName).toBe('Test User')
      expect(party.partyType).toBe('customer')
      expect(item.name).toBe('Test Item')
    })
  })

  describe('Data Integrity', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Integrity Test Company',
        domain: 'integrity-test'
      }).returning()
      tenantId = tenant.id
    })

    it('should maintain referential integrity', async () => {
      // Create dependent entities
      const [party] = await db.insert(parties).values({
        partyType: 'customer',
        code: 'REF-001',
        tenantId
      }).returning()

      const [item] = await db.insert(items).values({
        name: 'Ref Item',
        itemType: 'product',
        code: 'REF-ITEM-001',
        tenantId
      }).returning()

      expect(party.tenantId).toBe(tenantId)
      expect(item.tenantId).toBe(tenantId)
    })
  })

  describe('Data Types and Constraints', () => {
    let tenantId: string

    beforeEach(async () => {
      const [tenant] = await db.insert(tenants).values({
        name: 'Data Types Test',
        domain: 'data-types'
      }).returning()
      tenantId = tenant.id
    })

    it('should handle timestamp fields correctly', async () => {
      const [party] = await db.insert(parties).values({
        partyType: 'customer',
        code: 'TIME-TEST-001',
        status: 'active',
        tenantId
      }).returning()

      expect(party.insertedAt).toBeDefined()
      expect(party.updatedAt).toBeDefined()
      expect(party.insertedAt).toBeInstanceOf(Date)
      expect(party.updatedAt).toBeInstanceOf(Date)
    })

    it('should handle boolean fields with defaults', async () => {
      const [user] = await db.insert(users).values({
        displayName: 'Boolean Test User',
        status: 'active'
        // twoFactorEnabled not specified, should default to false
      }).returning()

      expect(user.twoFactorEnabled).toBe(false)

      const [user2] = await db.insert(users).values({
        displayName: 'Boolean Test User 2',
        status: 'active',
        twoFactorEnabled: true
      }).returning()

      expect(user2.twoFactorEnabled).toBe(true)
    })

    it('should validate required fields', async () => {
      await expect(
        db.insert(items).values({
          // name missing, itemType missing
          code: 'NO-NAME',
          tenantId
        } as any)
      ).rejects.toThrow()
    })
  })
})

// Helper function for SQL templating (if not imported)
import { sql } from 'drizzle-orm'